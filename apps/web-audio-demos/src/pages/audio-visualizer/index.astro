<canvas id="visualizer"></canvas>

<div class="controls">
  <label for="audioFile">Load Audio File</label>
  <input type="file" id="audioFile" accept="audio/*" />

  <button id="playPause" disabled>Play</button>

  <select id="visualizerType">
    <option value="bars">Frequency Bars</option>
    <option value="waveform">Waveform</option>
    <option value="circular">Circular</option>
  </select>
</div>

<div class="info">
  <p>Load an audio file to start visualizing</p>
</div>

<script>
  type VisualizerType = "bars" | "waveform" | "circular";

  interface AudioVisualizerConfig {
    canvasId: string;
    fftSize?: number;
    smoothingTimeConstant?: number;
  }

  class AudioVisualizer {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private width: number = 0;
    private height: number = 0;

    private audioContext: AudioContext | null = null;
    private analyser: AnalyserNode | null = null;
    private audioBuffer: AudioBuffer | null = null;
    private source: AudioBufferSourceNode | null = null;
    private startTime: number = 0;
    private pauseTime: number = 0;
    public isPlaying: boolean = false;

    private dataArray: Uint8Array | null = null;
    private bufferLength: number = 0;

    private animationId: number | null = null;
    private visualizerType: VisualizerType = "bars";

    public onEnded?: () => void;

    private fftSize: number;
    private smoothingTimeConstant: number;

    constructor(config: AudioVisualizerConfig) {
      const canvasElement = document.getElementById(config.canvasId);
      if (!(canvasElement instanceof HTMLCanvasElement)) {
        throw new Error(`Element with id "${config.canvasId}" is not a canvas`);
      }

      this.canvas = canvasElement;
      const context = this.canvas.getContext("2d", { alpha: false });
      if (!context) {
        throw new Error("Could not get 2D context from canvas");
      }
      this.ctx = context;

      this.fftSize = config.fftSize ?? 512;
      this.smoothingTimeConstant = config.smoothingTimeConstant ?? 0.8;

      this.resize();
      window.addEventListener("resize", () => this.resize());

      // Bind methods
      this.draw = this.draw.bind(this);
    }

    private resize(): void {
      const rect = this.canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;

      this.ctx.scale(dpr, dpr);

      this.width = rect.width;
      this.height = rect.height;
    }

    async initAudio(file: File): Promise<void> {
      // Create audio context on user interaction
      if (!this.audioContext) {
        this.audioContext = new (
          window.AudioContext || (window as any).webkitAudioContext
        )();
      }

      // Setup analyser
      if (!this.analyser) {
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = this.fftSize;
        this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;

        this.bufferLength = this.analyser.frequencyBinCount;
        this.dataArray = new Uint8Array(this.bufferLength);

        // Connect analyser to destination
        this.analyser.connect(this.audioContext.destination);
      }

      // Decode audio file
      const arrayBuffer = await file.arrayBuffer();
      this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      this.pauseTime = 0;
    }

    play(): void {
      if (!this.audioContext || !this.audioBuffer || !this.analyser) {
        console.warn("Audio not initialized");
        return;
      }

      if (this.audioContext.state === "suspended") {
        this.audioContext.resume();
      }

      // Stop current source if exists
      if (this.source) {
        this.source.stop();
      }

      // Create new buffer source
      this.source = this.audioContext.createBufferSource();
      this.source.buffer = this.audioBuffer;
      this.source.connect(this.analyser);

      // Handle playback end
      this.source.onended = () => {
        if (this.isPlaying) {
          this.isPlaying = false;
          this.pauseTime = 0;
          this.stopAnimation();
          if (this.onEnded) this.onEnded();
        }
      };

      // Start from pause position
      this.startTime = this.audioContext.currentTime - this.pauseTime;
      this.source.start(0, this.pauseTime);
      this.isPlaying = true;
      this.startAnimation();
    }

    pause(): void {
      if (!this.audioContext || !this.source || !this.isPlaying) {
        return;
      }

      this.pauseTime = this.audioContext.currentTime - this.startTime;
      this.source.stop();
      this.isPlaying = false;
      this.stopAnimation();
    }

    private startAnimation(): void {
      if (!this.animationId) {
        this.draw();
      }
    }

    private stopAnimation(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }

    setVisualizerType(type: VisualizerType): void {
      this.visualizerType = type;
    }

    private draw(): void {
      this.animationId = requestAnimationFrame(this.draw);

      if (!this.analyser || !this.dataArray) {
        return;
      }

      // Get frequency or waveform data
      if (this.visualizerType === "waveform") {
        this.analyser.getByteTimeDomainData(this.dataArray);
      } else {
        this.analyser.getByteFrequencyData(this.dataArray);
      }

      // Clear canvas
      this.ctx.fillStyle = "#1a1a1a";
      this.ctx.fillRect(0, 0, this.width, this.height);

      // Draw based on type
      switch (this.visualizerType) {
        case "bars":
          this.drawBars();
          break;
        case "waveform":
          this.drawWaveform();
          break;
        case "circular":
          this.drawCircular();
          break;
      }
    }

    private drawBars(): void {
      if (!this.dataArray) return;

      const barWidth = this.width / this.bufferLength;
      const barGap = 1;

      for (let i = 0; i < this.bufferLength; i++) {
        const barHeight = (this.dataArray[i] / 255) * this.height * 0.8;

        // Gradient from bottom to top
        const gradient = this.ctx.createLinearGradient(
          0,
          this.height - barHeight,
          0,
          this.height,
        );
        gradient.addColorStop(0, "#3b82f6");
        gradient.addColorStop(1, "#8b5cf6");

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(
          i * barWidth,
          this.height - barHeight,
          barWidth - barGap,
          barHeight,
        );
      }
    }

    private drawWaveform(): void {
      if (!this.dataArray) return;

      this.ctx.lineWidth = 2;
      this.ctx.strokeStyle = "#3b82f6";
      this.ctx.beginPath();

      const sliceWidth = this.width / this.bufferLength;
      let x = 0;

      for (let i = 0; i < this.bufferLength; i++) {
        const v = this.dataArray[i] / 128.0;
        const y = (v * this.height) / 2;

        if (i === 0) {
          this.ctx.moveTo(x, y);
        } else {
          this.ctx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      this.ctx.lineTo(this.width, this.height / 2);
      this.ctx.stroke();
    }

    private drawCircular(): void {
      if (!this.dataArray) return;

      const centerX = this.width / 2;
      const centerY = this.height / 2;
      const radius = Math.min(this.width, this.height) * 0.3;

      const angleStep = (Math.PI * 2) / this.bufferLength;

      for (let i = 0; i < this.bufferLength; i++) {
        const angle = i * angleStep - Math.PI / 2;
        const barHeight = (this.dataArray[i] / 255) * (radius * 0.8);

        const x1 = centerX + Math.cos(angle) * radius;
        const y1 = centerY + Math.sin(angle) * radius;
        const x2 = centerX + Math.cos(angle) * (radius + barHeight);
        const y2 = centerY + Math.sin(angle) * (radius + barHeight);

        // Color based on frequency
        const hue = (i / this.bufferLength) * 360;
        this.ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
        this.ctx.lineWidth = 2;

        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
      }
    }
  }

  // Initialize
  const visualizer = new AudioVisualizer({
    canvasId: "visualizer",
    fftSize: 512,
    smoothingTimeConstant: 0.8,
  });

  // UI Controls
  const fileInput = document.getElementById("audioFile") as HTMLInputElement;
  const playPauseBtn = document.getElementById(
    "playPause",
  ) as HTMLButtonElement;
  const visualizerTypeSelect = document.getElementById(
    "visualizerType",
  ) as HTMLSelectElement;
  const infoText = document.querySelector(".info p") as HTMLParagraphElement;

  fileInput.addEventListener("change", async (e) => {
    const target = e.target as HTMLInputElement;
    const file = target.files?.[0];
    if (!file) return;

    infoText.textContent = `Loading: ${file.name}...`;

    try {
      await visualizer.initAudio(file);
      infoText.textContent = `Loaded: ${file.name}`;
      playPauseBtn.disabled = false;
      playPauseBtn.textContent = "Play";

      // Setup callback for when audio ends
      visualizer.onEnded = () => {
        playPauseBtn.textContent = "Play";
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error";
      infoText.textContent = `Error loading file: ${errorMessage}`;
    }
  });

  playPauseBtn.addEventListener("click", () => {
    if (!visualizer.isPlaying) {
      visualizer.play();
      playPauseBtn.textContent = "Pause";
    } else {
      visualizer.pause();
      playPauseBtn.textContent = "Play";
    }
  });

  visualizerTypeSelect.addEventListener("change", (e) => {
    const target = e.target as HTMLSelectElement;
    visualizer.setVisualizerType(target.value as VisualizerType);
  });
</script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family:
      system-ui,
      -apple-system,
      sans-serif;
    background: #0a0a0a;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 20px;
  }

  #visualizer {
    width: 100%;
    max-width: 800px;
    height: 300px;
    background: #1a1a1a;
    border-radius: 8px;
    /* Performance hint for browser */
    will-change: transform;
  }

  .controls {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
  }

  button {
    padding: 10px 20px;
    background: #2563eb;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
  }

  button:hover {
    background: #1d4ed8;
  }

  button:disabled {
    background: #4b5563;
    cursor: not-allowed;
  }

  select {
    padding: 8px 12px;
    background: #374151;
    color: white;
    border: 1px solid #4b5563;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
  }

  input[type="file"] {
    display: none;
  }

  label {
    padding: 10px 20px;
    background: #059669;
    color: white;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
  }

  label:hover {
    background: #047857;
  }

  .info {
    margin-top: 10px;
    font-size: 14px;
    color: #9ca3af;
  }
</style>
